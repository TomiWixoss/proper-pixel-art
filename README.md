# Proper Pixel Art 
## Summary
- Converts noisy, high resolution pixel-art-style images such as those produced by generative models to true pixel resolution assets.

- Clean screenshots or low-quality web uploads of sprites.

## Installation

### Clone the Repository:
```bash
git clone git@github.com:KennethJAllen/proper-pixel-art.git
cd proper-pixel-art
```
### Create Virtual Environment

- Install [uv](https://docs.astral.sh/uv/getting-started/installation/) if not already installed.
- Sync environments
    - `uv sync`

## Usage

First, obtain a source pixel-art-style image (e.g. a pixel-art-style image generated by GPT-4o or a screenshot of pixel-art).

### CLI

```bash
uv run ppa -i <input_path> -o <output_path> -c <num_colors> -p <pixel_size> [-t]
# or directly using uvx
uvx --from https://github.com/KennethJAllen/proper-pixel-art.git ppa -i <input_path> -o <output_path> -c <num_colors> -p <pixel_size> [-t]
```

#### Flags

| Flag                         | Description                                                                                               |
| ---------------------------- | --------------------------------------------------------------------------------------------------------- |
| `-i`, `--input` `<path>`     | Source image file in pixel-art-style                                                                      |
| `-o`, `--output` `<path>`    | Output directory or file path for result. (default: '.')                                                  |
| `-c`, `--colors` `<int>`     | Number of colors for output. May need to try a few different values. (default 16)                         |
| `-p`, `--pixel-size` `<int>` | Size of each “pixel” in the output. (default: 1)                                                          |
| `-t`, `--transparent`        | Output with transparent background. (default: off)                                                        |
| `-w`, `--pixel-width`        | Width of the pixels in the input image. If not set, it will be determined automatically. (default: None)  |
| `-s`, `--upscale-factor`     | Initial image upscale factor. Increasing this may help detect pixel edges. (default 2)                    |

#### Example

`uv run ppa -i assets/blob/blob.png -o . -c 16 -p 20 -t`

### Python

#### Simple Example

```python
from PIL import Image
from proper_pixel_art.pixelate import pixelate

image = Image.open('input.png')
result = pixelate(image, num_colors=16)
result.save('output.png')
```

#### Parameters

- `image` : `PIL.Image.Image`

  - A PIL image to pixelate.

- `num_colors` : `int`

  - The number of colors in result.
  - May need to try a few values if the colors don't look right.
  - 8, 16, 32, or 64 typically works.

- `pixel_size` : `int`

  - Upscale result after algorithm is complete if not None.

- `upsample_factor` : `int`

  - Upscale initial image. This may help detect lines.

- `transparent_background` : `bool`
  - If True, floos fills each corner of the result with transparent alpha.

- `intermediate_dir` : `Path | None` 

  - Directory to save images visualizing intermediate steps of algorithm. Useful for development.

#### Returns

A PIL image with 

## Examples

The algorithm is robust. It performs well for images that are already approximately alligned to a grid.

Here are a few examples. A mesh is computed, where each cell corresponds to one pixel.

### Bat
- Generated by GPT-4o.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/bat/bat.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/bat/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/bat/upsampled.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

### Ash
- Screenshot from Google images of Pokemon asset.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/ash/ash.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/ash/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/ash/upsampled.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>


### Demon
- Original image generated by GPT-4o.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/demon/demon.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/demon/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/demon/upsampled.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

### Pumpkin
- Screenshot from Google Images of Stardew Valley asset. This is an adversarial exmaple as the source image is both low quality and the object is round.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/pumpkin/pumpkin.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/pumpkin/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/pumpkin/upsampled.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>


## Real Images To Pixel Art

- This tool can also be used to convert real images to pixel art by first requesting a pixelated version of the original image from GPT-4o, then using the tool to get the true pixel-resolution image.

- Consider this image of a mountain

<img src="./assets/mountain/real.jpg" width="50%" alt="Original mountain"/>

- Here are the results of first requesting a pixalated version of the mountain, then using the tool to get a true resolution pixel art version.

<table align="center" width="100%">
  <tr>
    <td width="33%">
      <img src="./assets/mountain/mountain.png" style="width:100%;" />
      <br><small>Noisy, High Resolution</small>
    </td>
    <td width="33%">
      <img src="./assets/mountain/mesh.png" style="width:100%;" />
      <br><small>Mesh</small>
    </td>
    <td width="33%">
      <img src="./assets/mountain/upsampled.png" style="width:100%;" />
      <br><small>True Pixel Resolution</small>
    </td>
  </tr>
</table>

## Challenges
The result of pixel-art style images from LLMs are noisy, high resolution images with a non-uniform grid and random artifacts. Due to these issues, standard downsampling techniques do not work. How can we recover the pixel art with "true" resolution and colors?

The current approach to turning pixel art into useable assets for games are either
1) Use naive downsampling which does not give a result that is faithful to the original image.
2) Manually re-create the image in the approperiate resolution pixel by pixel.

## Algorithm
- The main algorithm solves these challenges. Here is a high level overview. We will apply it step by step on this example image of blob pixel art that was generated from GPT-4o.

<img src="./assets/blob/blob.png" width="80%" alt="blob"/>

- Note that this image is high resolution and noisy.

<img src="./assets/blob/zoom.png" width="80%" alt="The blob is noisy."/>

1) Trim the edges of the image and zero out pixels with more than 50% alpha.
    - This is to work around some issues with models such as GPT-4o not giving a perfectly transparent background.

2) Upscale by a factor of 2 using nearest neighbor.
    - This can help identify the correct pixel mesh.
    - It is possible that a similar result could be achived by tuning the parameters in the following steps. Further investigation is required.

3) Find edges of the pixel art using [Canny edge detection](https://docs.opencv.org/4.x/da/d22/tutorial_py_canny.html).

<img src="./assets/blob/edges.png" width="80%" alt="blob edges"/>

4) Close small gaps in edges with a [morphological closing](https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html).

<img src="./assets/blob/closed_edges.png" width="80%" alt="blob closed edges"/>

5) Take the [probabalistic Hough transform](https://docs.opencv.org/4.x/d3/de6/tutorial_js_houghlines.html) to get the coordinates of lines in the detected edges. Only keep lines that are close to vertical or horizontal giving some grid coordinates. Cluster lines that are closeby together.

<img src="./assets/blob/lines.png" width="80%" alt="blob lines"/>

6) Find the grid spacing by filtering outliers and taking the median of the spacings, then complete the mesh.

<img src="./assets/blob/mesh.png" width="80%" alt="blob mesh"/>

7) Quantize the original image to a small number of colors.
    - Note: The result is sensitive to the number of colors chosen.
    - The parameter is not difficult to tune, but the script may need to be re-run if the colors don't look right.
    - 8, 16, 32, or 64 typically works.

8) In each cell specified by the mesh, choose the most common color in the cell as the color for the pixel. Recreate the original image with one pixel per cell.

    - Result upscaled by a factor of $20 \times$ using nearest neighbor.

<img src="./assets/blob/upsampled.png" width="80%" alt="blob upscaled"/>
